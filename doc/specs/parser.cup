package compiler.syntax;

// Declaraci�n de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaracion del codigo de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaracion de terminales

terminal Token PLUS;
terminal Token MINUS;
terminal Token DIVIDE;
terminal Token TIMES;

terminal Token STRING;
terminal Token INTEGER_LITERAL;

terminal Token AND;
terminal Token ARRAY;
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CONST;
terminal Token DO;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FOR;
terminal Token IF;
terminal Token INTEGER;
terminal Token MODULE;
terminal Token NOT;
terminal Token OF;
terminal Token OR;
terminal Token PROCEDURE;
terminal Token RECORD;
terminal Token RETURN;
terminal Token THEN;
terminal Token TO;
terminal Token TRUE;
terminal Token TYPE;
terminal Token VAR;
terminal Token WHILE;
terminal Token WRITESTRING;
terminal Token WRITEINT;
terminal Token WRITELN;

terminal Token ASSIGNMENT;
terminal Token EQUAL;
terminal Token LESS_THAN;
terminal Token MORE_THAN;
terminal Token NOT_EQUAL;
terminal Token DOT;
terminal Token COMMA;
terminal Token COLON;
terminal Token SEMICOLON;
terminal Token LEFT_PARENTHESIS;
terminal Token RIGHT_PARENTHESIS;
terminal Token LEFT_BRACKET;
terminal Token RIGHT_BRACKET;
terminal Token IDENTIFIER;

// Declaracion de no terminales
// no modificar los propuestos

non terminal  			program;
non terminal Axiom		axiom;
non terminal			module_header, declaration_blocks_spec, begin_spec, end_spec;
non terminal			const_spec, const_list, const_block;
non terminal			var_spec, var_list, var_block;
non terminal			type_spec, type_list, record_type, record_header, record_var_list, record_var, record_end;
non terminal			subp_spec, subp_list, proc, func, proc_header, func_header, subp_header, subp_params, param_block_list, param_block_sub_list, param_block, func_return, func_return_values, by_reference;
non terminal			stmt_spec;
non terminal			stmt_list, stmt, expr, proc_call_stmt, proc_call_expr, proc_call_params, expr_list, expr_sub_list, else_part;

non terminal			vector, vector_index;
non terminal			writestring_params, writeint_params, writeln_paren;

non terminal			ident_list, ident_sub_list, var_type, prim_types, const_value, ident_plus, ident_plus_options, property_access, not_part;

// Declaracion de relaciones de precedencia
precedence left     PLUS, MINUS, DIVIDE;
precedence left     LESS_THAN, NOT_EQUAL, AND;

// Declaracion de reglas de produccion

start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {: 
  		// No modificar esta estructura, aunque se pueden anadir mas acciones semanticas
  		// Para la entrega de febrero pueden comentarse las dos sentencias siguientes:
  		//List intermediateCode = ax.getIntermediateCode ();
  		//finalCodeFactory.create (intermediateCode);
  		// En caso de no comentarse las sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest en la entrega de Febrero. Esto es debido a que 
  		// aun no se tendra implementada la generacion de codigo intermedio ni final.
  		// Para la entrega de Junio deberan descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};

/* module */
axiom ::= module_header declaration_blocks_spec begin_spec stmt_spec end_spec; 
module_header ::= MODULE IDENTIFIER SEMICOLON;
declaration_blocks_spec ::= const_spec type_spec var_spec subp_spec;
begin_spec ::= BEGIN;
end_spec ::= END IDENTIFIER SEMICOLON;

/* constants */
const_spec ::= CONST const_list 
	| /* empty */;
const_list ::= const_block const_list 
	| /* empty */;
const_block ::= ident_list EQUAL not_part const_value SEMICOLON;

/* types - record */
type_spec ::= TYPE type_list 
	| /*empty */;
type_list ::= type_list record_type 
	| record_type;
record_type ::= record_header record_var_list record_end;
record_header ::= IDENTIFIER EQUAL RECORD;
record_var_list ::= record_var_list record_var 
	| record_var;
record_var ::= IDENTIFIER COLON prim_types SEMICOLON;
record_end ::= END SEMICOLON;

/* vars */
var_spec ::= VAR var_list 
	| /* empty */;
var_list ::= var_block var_list 
	| /* empty */;
var_block ::= ident_list COLON var_type SEMICOLON;

/* subprograms */
subp_spec ::= subp_list 
	| /* empty */;
subp_list ::= subp_list proc 
	| subp_list func 
	| proc 
	| func;
proc ::= proc_header declaration_blocks_spec begin_spec stmt_spec end_spec;
func ::= func_header declaration_blocks_spec begin_spec stmt_spec func_return end_spec;
proc_header ::= subp_header SEMICOLON;
func_header ::= subp_header COLON prim_types SEMICOLON;
subp_header ::= PROCEDURE IDENTIFIER subp_params;
func_return ::= RETURN func_return_values SEMICOLON;
func_return_values ::= IDENTIFIER 
	| INTEGER_LITERAL;
subp_params ::= LEFT_PARENTHESIS param_block_list RIGHT_PARENTHESIS 
	| /* empty */;
param_block_list ::= param_block param_block_sub_list 
	| /* empty */;
param_block_sub_list ::= SEMICOLON param_block param_block_sub_list 
	| /* empty */;
param_block ::= by_reference ident_list COLON var_type;
by_reference ::= VAR 
	| /* empty */;

/* statements */
stmt_spec ::= stmt_list 
	| /* empty */;
stmt_list ::= stmt_list stmt 
	| stmt;
stmt ::= proc_call_stmt SEMICOLON
	| ident_plus ASSIGNMENT expr SEMICOLON
	| IF expr THEN stmt_spec else_part END SEMICOLON
	| WHILE expr DO stmt_spec END SEMICOLON
	| WRITESTRING LEFT_PARENTHESIS writestring_params RIGHT_PARENTHESIS SEMICOLON
	| WRITEINT LEFT_PARENTHESIS writeint_params RIGHT_PARENTHESIS SEMICOLON
	| WRITELN writeln_paren SEMICOLON;

else_part ::= ELSE stmt_spec 
	| /* empty */;

ident_plus ::= IDENTIFIER 
	| IDENTIFIER ident_plus_options;
ident_plus_options ::= vector 
	| property_access;
vector ::= LEFT_BRACKET vector_index RIGHT_BRACKET;
vector_index ::= ident_plus 
	| INTEGER_LITERAL 
	| vector;
property_access ::= DOT IDENTIFIER 
	| DOT IDENTIFIER property_access;

proc_call_stmt ::= IDENTIFIER 
	| proc_call_expr;
proc_call_expr ::= IDENTIFIER proc_call_params;
proc_call_params ::= LEFT_PARENTHESIS expr_list RIGHT_PARENTHESIS;

writestring_params ::= STRING 
	| ident_plus 
	| proc_call_expr;
writeint_params ::= INTEGER_LITERAL 
	| ident_plus 
	| proc_call_expr;
writeln_paren ::= LEFT_PARENTHESIS RIGHT_PARENTHESIS 
	| /* empty */;

expr ::= LEFT_PARENTHESIS expr RIGHT_PARENTHESIS
	| expr PLUS expr
	| expr DIVIDE expr
	| expr NOT_EQUAL expr
	| expr LESS_THAN expr
	| expr AND expr
	| NOT expr
	| ident_plus
	| proc_call_expr
	| const_value;

expr_list ::= expr expr_sub_list 
	| /* empty */; 
expr_sub_list ::= expr_sub_list COMMA expr 
	| /* empty */; 

/* common */
ident_list ::= IDENTIFIER ident_sub_list;
ident_sub_list  ::= ident_sub_list COMMA IDENTIFIER 
	| /* empty */;
var_type ::= IDENTIFIER 
	| prim_types;
prim_types ::= INTEGER 
	| BOOLEAN;
const_value ::= INTEGER_LITERAL 
	| TRUE 
	| FALSE;
not_part ::= NOT 
	| /* empty */;

/**
	TODO
	Write int con expresion.
	Precedencia de operadores. Estudiar y aplicar.
	Eliminar simbolos que no aplican en lexico y sintactico.
	Revisión de documentación y de la gramática.
*/

/* Una expresión es una construcción sintáctica del lenguaje que devuelve al 
contexto donde se evalúa un valor. Son expresiones los valores constantes de cualquier 
tipo, los identificadores de constantes, variables enumeraciones y parámetros, 
los elementos de vector, los campos de registros, y las llamadas a funciones. 
También son expresiones cualquier combinación sintácticamente correcta de 
expresiones utilizando operadores aritméticos, lógicos, relacionales y expresiones 
entre paréntesis. (Esta definición puede depender del lenguaje en concreto). */

/*
DUDAS

 - punto y coma al final de las listas de parametros. --> subp_params
 - Uso de NOT ¿el las constants? - https://2017.cursosvirtuales.uned.es/dotlrn/grados/asignaturas/71013130-17/uforums/thread-view?message_id=26196320
 - indice vectores - https://2017.cursosvirtuales.uned.es/dotlrn/grados/asignaturas/71013130-17/uforums/message-view?message_id=24854112
 
*/
