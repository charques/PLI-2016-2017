package compiler.syntax;

// Declaraci�n de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaracion del codigo de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaracion de terminales

terminal Token PLUS;
terminal Token MINUS;
terminal Token DIVIDE;
terminal Token TIMES;

terminal Token STRING;
terminal Token INTEGER_LITERAL;

terminal Token AND;
terminal Token ARRAY;
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CONST;
terminal Token DO;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FOR;
terminal Token IF;
terminal Token INTEGER;
terminal Token MODULE;
terminal Token NOT;
terminal Token OF;
terminal Token OR;
terminal Token PROCEDURE;
terminal Token RECORD;
terminal Token RETURN;
terminal Token THEN;
terminal Token TO;
terminal Token TRUE;
terminal Token TYPE;
terminal Token VAR;
terminal Token WHILE;
terminal Token WRITESTRING;
terminal Token WRITEINT;
terminal Token WRITELN;

terminal Token ASSIGNMENT;
terminal Token EQUAL;
terminal Token LESS_THAN;
terminal Token MORE_THAN;
terminal Token NOT_EQUAL;
terminal Token DOT;
terminal Token COMMA;
terminal Token COLON;
terminal Token SEMICOLON;
terminal Token LEFT_PARENTHESIS;
terminal Token RIGHT_PARENTHESIS;
terminal Token LEFT_BRACKET;
terminal Token RIGHT_BRACKET;
terminal Token IDENTIFIER;

// Declaracion de no terminales
// no modificar los propuestos

non terminal  			program;
non terminal Axiom		axiom;
non terminal			module_spec, begin_spec, body_spec, end_spec;
non terminal			const_spec, const_list, const, const_value;
non terminal			var_spec, var_list, var_block, ident_list, var_type;
non terminal			type_spec, type_list, record_type, record_header, record_var_list, record_var, record_var_type, record_end;
non terminal			expr_list, expr_part, expr;


// Declaracion de relaciones de precedencia
precedence left     PLUS, MINUS;
precedence left     TIMES, DIVIDE;

// Declaracion de reglas de produccion

start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {: 
  		// No modificar esta estructura, aunque se pueden a�adir m�s acciones sem�nticas
  		// Para la entrega de febrero pueden comentarse las dos sentencias siguientes:
  		//List intermediateCode = ax.getIntermediateCode ();
  		//finalCodeFactory.create (intermediateCode);
  		// En caso de no comentarse las sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest en la entrega de Febrero. Esto es debido a que 
  		// a�n no se tendr� implementada la generaci�n de c�digo intermedio ni final.
  		// Para la entrega de Junio deber�n descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};


axiom ::= 	module_spec const_spec type_spec var_spec begin_spec body_spec end_spec; 

module_spec ::= MODULE IDENTIFIER SEMICOLON;

const_spec ::= CONST const_list | /* empty */;
const_list ::= const_list const | const;
const ::= IDENTIFIER EQUAL const_value SEMICOLON;
const_value ::= INTEGER_LITERAL | TRUE | FALSE;

type_spec ::= TYPE type_list | /*empty */;
type_list ::= type_list record_type | record_type;
record_type ::= record_header record_var_list record_end;
record_header ::= IDENTIFIER EQUAL RECORD;
record_var_list ::= record_var_list record_var | record_var;
record_var ::= IDENTIFIER COLON record_var_type SEMICOLON;
record_end ::= END SEMICOLON;
record_var_type ::= INTEGER | BOOLEAN;

var_spec  ::=  VAR var_list | /* empty */;
var_list ::= var_block var_list | /* empty */;
var_block ::= IDENTIFIER ident_list COLON var_type SEMICOLON;
ident_list  ::= ident_list COMMA IDENTIFIER | /* empty */;
var_type ::= IDENTIFIER | INTEGER | BOOLEAN;

begin_spec ::= BEGIN;
body_spec ::= expr_list | /* empty */;
end_spec ::= END IDENTIFIER SEMICOLON;

