package compiler.syntax;

// Declaraci�n de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaracion del codigo de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaracion de terminales

terminal Token PLUS;
terminal Token MINUS;
terminal Token DIVIDE;
terminal Token TIMES;

terminal Token STRING;
terminal Token INTEGER_LITERAL;

terminal Token AND;
terminal Token ARRAY;
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CONST;
terminal Token DO;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FOR;
terminal Token IF;
terminal Token INTEGER;
terminal Token MODULE;
terminal Token NOT;
terminal Token OF;
terminal Token OR;
terminal Token PROCEDURE;
terminal Token RECORD;
terminal Token RETURN;
terminal Token THEN;
terminal Token TO;
terminal Token TRUE;
terminal Token TYPE;
terminal Token VAR;
terminal Token WHILE;
terminal Token WRITESTRING;
terminal Token WRITEINT;
terminal Token WRITELN;

terminal Token ASSIGNMENT;
terminal Token EQUAL;
terminal Token LESS_THAN;
terminal Token MORE_THAN;
terminal Token NOT_EQUAL;
terminal Token DOT;
terminal Token COMMA;
terminal Token COLON;
terminal Token SEMICOLON;
terminal Token LEFT_PARENTHESIS;
terminal Token RIGHT_PARENTHESIS;
terminal Token LEFT_BRACKET;
terminal Token RIGHT_BRACKET;
terminal Token IDENTIFIER;

// Declaracion de no terminales
// no modificar los propuestos

non terminal  			program;
non terminal Axiom		axiom;
non terminal			module_header, declaration_blocks_spec, begin_spec, end_spec;
non terminal			const_spec, const_list, const, const_value;
non terminal			var_spec, var_list, var_block;
non terminal			type_spec, type_list, record_type, record_header, record_var_list, record_var, record_end;
non terminal			subp_spec, subp_list, proc, func, proc_header, func_header, subp_header, subp_params, param_block_list, param_block_sub_list, param_block, func_return, func_return_values, by_reference;
non terminal			sent_spec;
non terminal			expr_list, expr_part, expr;

non terminal			ident_list, ident_sub_list, var_type, prim_types;

// Declaracion de relaciones de precedencia
precedence left     PLUS, MINUS;
precedence left     TIMES, DIVIDE;

// Declaracion de reglas de produccion

start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {: 
  		// No modificar esta estructura, aunque se pueden a�adir m�s acciones sem�nticas
  		// Para la entrega de febrero pueden comentarse las dos sentencias siguientes:
  		//List intermediateCode = ax.getIntermediateCode ();
  		//finalCodeFactory.create (intermediateCode);
  		// En caso de no comentarse las sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest en la entrega de Febrero. Esto es debido a que 
  		// a�n no se tendr� implementada la generaci�n de c�digo intermedio ni final.
  		// Para la entrega de Junio deber�n descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};

/* module */
axiom ::= module_header declaration_blocks_spec begin_spec sent_spec end_spec; 
module_header ::= MODULE IDENTIFIER SEMICOLON;
declaration_blocks_spec ::= const_spec type_spec var_spec subp_spec;
begin_spec ::= BEGIN;
end_spec ::= END IDENTIFIER SEMICOLON;

/* constants */
const_spec ::= CONST const_list | /* empty */;
const_list ::= const_list const | const;
const ::= IDENTIFIER EQUAL const_value SEMICOLON;
const_value ::= INTEGER_LITERAL | TRUE | FALSE;

/* types - record */
type_spec ::= TYPE type_list | /*empty */;
type_list ::= type_list record_type | record_type;
record_type ::= record_header record_var_list record_end;
record_header ::= IDENTIFIER EQUAL RECORD;
record_var_list ::= record_var_list record_var | record_var;
record_var ::= IDENTIFIER COLON prim_types SEMICOLON;
record_end ::= END SEMICOLON;

/* vars */
var_spec  ::=  VAR var_list | /* empty */;
var_list ::= var_block var_list | /* empty */;
var_block ::= ident_list COLON var_type SEMICOLON;

/* subprograms */
subp_spec ::= subp_list | /* empty */;
subp_list ::= subp_list proc | subp_list func | proc | func;
proc ::= proc_header declaration_blocks_spec begin_spec sent_spec end_spec;
func ::= func_header declaration_blocks_spec begin_spec sent_spec func_return end_spec;
proc_header ::= subp_header SEMICOLON;
func_header ::= subp_header COLON prim_types SEMICOLON;
subp_header ::= PROCEDURE IDENTIFIER subp_params;
func_return ::= RETURN func_return_values SEMICOLON;
func_return_values ::= IDENTIFIER | INTEGER_LITERAL;
subp_params ::= LEFT_PARENTHESIS param_block_list RIGHT_PARENTHESIS | /* empty */;
param_block_list ::= param_block param_block_sub_list;
param_block_sub_list ::= SEMICOLON param_block param_block_sub_list | /* empty */;
param_block ::= by_reference ident_list COLON var_type;
by_reference ::= VAR | /* empty */;

sent_spec ::= expr_list | /* empty */;

/* common */
ident_list ::= IDENTIFIER ident_sub_list;
ident_sub_list  ::= ident_sub_list COMMA IDENTIFIER | /* empty */;
var_type ::= IDENTIFIER | INTEGER | BOOLEAN;
prim_types ::= INTEGER | BOOLEAN;
